<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">

  <!-- Imporant meta information to make the page as rigid as possible on mobiles, to avoid unintentional zooming on the page itself  -->
  <meta name="viewport"
    content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Character Tutorial</title>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      background: #25252B;
    }

    * {
      touch-action: manipulation;
    }

    *,
    *:before,
    *:after {
      box-sizing: border-box;
    }

    body {
      position: relative;
      color: white;
      letter-spacing: 2px;
      font-size: 11px;
      font-family: 'Poppins', sans-serif;
      width: 100%;
      height: 100vh;
    }

    .wrapper {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: radial-gradient(at 0 0px, #5262a5 30%, #404a72 50%, #212740 80%);
      width: 100%;
      height: 100%;
      position: relative;
    }

    #c {
      position: absolute;
      top: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .loading {
      position: fixed;
      z-index: 50;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: #f1f1f1;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .loader {
      -webkit-perspective: 120px;
      -moz-perspective: 120px;
      -ms-perspective: 120px;
      perspective: 120px;
      width: 100px;
      height: 100px;
    }

    .loader:before {
      content: "";
      position: absolute;
      left: 25px;
      top: 25px;
      width: 50px;
      height: 50px;
      background-color: #9bffaf;
      animation: flip 1s infinite;
    }

    @keyframes flip {
      0% {
        transform: rotate(0);
      }

      50% {
        transform: rotateY(180deg);
      }

      100% {
        transform: rotateY(180deg) rotateX(180deg);
      }
    }
  </style>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
    }

    .wrapper:after {
      content: "";
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      background: linear-gradient(180deg, #101320 50%, transparent);
    }

    #c {
      width: 100%;
      height: 100%;
      display: block;
      z-index: 1;
    }
  </style>
</head>

<body>

  <!-- The loading elem
     ent overlays all else until the model is loaded, at which point we remove this element from the DOM -->
  <!-- <div class="loading" id="js-loader"><div class="loader"></div></div> -->

  <div class="wrapper">
    <!-- The canvas element is used to draw the 3D scene -->
    <canvas id="c"></canvas>

  </div>
</body>

</html>

<script type="module">
  import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/build/three.module.js';
import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/examples/jsm/controls/OrbitControls.js';
import {GLTFLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/examples/jsm/loaders/GLTFLoader.js';

function Clamp(value, max, min) {
    return Math.min(Math.max(min, value), max)
}

function main() {
  const canvas = document.querySelector('#c');
  console.log(canvas);
  const renderer = new THREE.WebGLRenderer({canvas,alpha: true,antialias: true,physicallyCorrectLights:true, autoSize: true });
  renderer.setClearColor( 0x000000, 0 );
  renderer.outputEncoding = THREE.sRGBEncoding;
  const fov = 65;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 100;
  const fullbodyMinDist = 0.8
  const fullbodyMaxDist = 2.5

  const halfbodyMinDist = 0.5
  const halfbodyMaxDist = 1.2
  const halfbodyCamTarget = 0.1
  const fullbodyCamTarget = 1.6
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.set(0, 0, 20);
  

  var dirLight = new THREE.DirectionalLight()
  dirLight.intensity = 0.5
  dirLight.color = new THREE.Color(0xffffff)
  dirLight.shadow.bias = -0.0001
  dirLight.shadow.mapSize.height = 2048
  dirLight.shadow.mapSize.width = 2048
  dirLight.castShadow = true
  dirLight.position.set(3,5,0)
  camera.add(dirLight)

  var ambientLight = new THREE.AmbientLight()
  ambientLight.intensity = 0
  camera.add(ambientLight)

  var spotLight = new THREE.SpotLight()
  spotLight.intensity = 0
  spotLight.angle = 0.2
  spotLight.penumbra = 1
  spotLight.position.set(5, 25, 20)
  camera.add(spotLight)

  const color = 0xFFFFFF;
  const intensity = 5;
  const light = new THREE.DirectionalLight(color, intensity);
  light.position.set(0, 800, -800);
  camera.add(light);
  camera.add(light.target);

    // Add lights
    let hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.5);
    hemiLight.position.set(0, 50, 0);
    // Add hemisphere light to scene
    camera.add(hemiLight);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 15, 0);
    // controls.enablePan = false;
    // controls.enableDamping = true;
    controls.minDistance = 0.5
    controls.maxDistance =1.2
    controls.minPolarAngle = 1.4;
    controls.maxPolarAngle = 1.4;
    controls.minZoom = 1.4;
    // controls.enabled = false;
    controls.target.set(0, fullbodyCamTarget, 0);
    controls.update();
    var controlsUpdating = false;


    controls.addEventListener('change', () => {
      controlsUpdating = true;
      if(controlsUpdating){
        // console.log("do this");
        let distance = controls.target.distanceTo(camera.position)
        distance = Clamp(distance, fullbodyMaxDist, fullbodyMinDist)
        let pivot = (distance - fullbodyMinDist) / (fullbodyMaxDist - fullbodyMinDist)
        controls.target.set(0, fullbodyCamTarget - 0.6 * pivot, 0);
      //  controlsUpdating = false;
      }
    });


    const scene = new THREE.Scene();
    scene.add(camera)

  // scene.background = null;

  {
    // const planeSize = 1400;

    // const loader = new THREE.TextureLoader();
    // const texture = loader.load('texture.png');
    // texture.wrapS = THREE.RepeatWrapping;
    // texture.wrapT = THREE.RepeatWrapping;
    // texture.magFilter = THREE.NearestFilter;
    // const repeats = planeSize /12;
    // texture.repeat.set(repeats, repeats);

    // const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
    // const planeMat = new THREE.MeshPhongMaterial({
    //   map: texture,
    //   side: THREE.DoubleSide,
    // });
    // const mesh = new THREE.Mesh(planeGeo, planeMat);
    // mesh.rotation.x = Math.PI * -.5;
    // scene.add(mesh);
  }

  {
    // const skyColor = 0xB1E1FF;  // light blue
    // const groundColor = 0xB97A20;  // brownish orange
    // const intensity = 1;
    // const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
    // scene.add(light);
  }

  {
    // const color = 0xFFFFFF;
    // const intensity = 5;
    // const light = new THREE.DirectionalLight(color, intensity);
    // light.position.set(0, 800, -800);
    // scene.add(light);
    // scene.add(light.target);
  }

  {
    //  // Add lights
    // let hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.5);
    // hemiLight.position.set(0, 50, 0);
    // // Add hemisphere light to scene
    // scene.add(hemiLight);

    // let d = 8.25;
    // let dirLight = new THREE.DirectionalLight(0xffffff, 0.54);
    // dirLight.position.set(-8, 12, 8);
    // dirLight.castShadow = true;
    // dirLight.shadow.mapSize = new THREE.Vector2(1024, 1024);
    // dirLight.shadow.camera.near = 0.1;
    // dirLight.shadow.camera.far = 1500;
    // dirLight.shadow.camera.left = d * -1;
    // dirLight.shadow.camera.right = d;
    // dirLight.shadow.camera.top = d;
    // dirLight.shadow.camera.bottom = d * -1;
    // // Add directional Light to scene
    // scene.add(dirLight);

    // // Floor
    // let floorGeometry = new THREE.PlaneGeometry(50, 50, 0, 0);
    // let floorMaterial = new THREE.MeshPhongMaterial({
    //   color: 0xFFFFFF,
    //   shininess: 0
    // });

    // let floor = new THREE.Mesh(floorGeometry, floorMaterial);
    // floor.rotation.x = -0.5 * Math.PI;
    // floor.receiveShadow = true;
    // floor.position.y = -11;
    // // scene.add(floor);

    // let geometry = new THREE.SphereGeometry(8, 32, 32);
    // let material = new THREE.MeshBasicMaterial({ color: 0x9bffaf }); // 0xf2ce2e
    // let sphere = new THREE.Mesh(geometry, material);

    // sphere.position.z = -15;
    // sphere.position.y = -2.5;
    // sphere.position.x = -0.25;
    // // scene.add(sphere);
  }
  function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
    const halfSizeToFitOnScreen = sizeToFitOnScreen * 1;
    const halfFovY = THREE.MathUtils.degToRad(camera.fov * .5);
    const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
    // compute a unit vector that points in the direction the camera is now
    // in the xz plane from the center of the box
    const direction = (new THREE.Vector3())
        .subVectors(camera.position, boxCenter)
        .multiply(new THREE.Vector3(1, 1, 1))
        .normalize();

    // move the camera to a position distance units way from the center
    // in whatever direction the camera was from the center already
    camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));

    // pick some near and far values for the frustum that
    // will contain the box.
    camera.near = boxSize / 100;
    camera.far = boxSize * 100;

    camera.updateProjectionMatrix();

    // point the camera to look at the center of the box
    camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
  }

  {
    const gltfLoader = new GLTFLoader();
    gltfLoader.load('rana_avatar_3_pose.glb', (gltf) => {
      const root = gltf.scene;
      scene.add(root);

      // compute the box that contains all the stuff
      // from root and below
      const box = new THREE.Box3().setFromObject(root);

      const boxSize = box.getSize(new THREE.Vector3()).length()/1.8;
      const boxCenter = box.getCenter(new THREE.Vector3());

      // set the camera to frame the box
      frameArea(boxSize * 1, boxSize, boxCenter, camera);

      // update the Trackball controls to handle the new size
      controls.maxDistance = boxSize * 10;
      controls.target.copy(boxCenter);
      controls.update();
    });
  }

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render() {
    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}

main();

</script>